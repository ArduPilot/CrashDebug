/*  Copyright (C) 2014  Adam Green (https://github.com/adamgreen)

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/
#include <common.h>
#include <CrashDebugCommandLine.h>
#include <FileFailureInject.h>
#include <GdbLogParser.h>
#include <MallocFailureInject.h>
#include <MemorySim.h>
#include <printfSpy.h>
#include <stdio.h>
#include <string.h>
#include <version.h>


static void displayCopyrightNotice(void)
{
    printf("CrashDebug - Cortex-M Post-Mortem Debugging Aid (" VERSION_STRING ")\n\n"
           COPYRIGHT_NOTICE
           "\n");
}

static void displayUsage(void)
{
    printf("Usage: CrashDebug --image imageFilename --dump dumpFilename\n"
           "Where: --image is the required name of the image loaded into the device's FLASH when the crash occurred.\n"
           "         Supported Formats:\n"
           "           .bin - Image files with a .bin extentension.  These are typically generated by running\n"
           "                  \"arm-none-eabi-objcopy -o binary input.elf output.bin\"\n"
           "       --dump is the required name of the crash dump which contains the contents of RAM and the CPU\n"
           "         registers at the time of the crash.\n"
           "         Supported Format:\n"
           "           gdb.txt - Crash dump created by logging results from GDB commands.\n");
}


static int parseArgument(CrashDebugCommandLine* pThis, int index, int argc, const char** ppArgs);
static int hasDoubleDashPrefix(const char* pArgument);
static int parseFlagArgument(CrashDebugCommandLine* pThis, int argc, const char** ppArgs);
static int parseImageFilenameOption(CrashDebugCommandLine* pThis, int argc, const char** ppArgs);
static int parseDumpFilenameOption(CrashDebugCommandLine* pThis, int argc, const char** ppArgs);
static int parseFilenameOption(CrashDebugCommandLine* pThis, int argc, const char** ppArgs, const char** ppFilename);
static void throwIfRequiredArgumentNotSpecified(CrashDebugCommandLine* pThis);
static void loadImageFile(CrashDebugCommandLine* pThis);


__throws void CrashDebugCommandLine_Init(CrashDebugCommandLine* pThis, int argc, const char** argv)
{
    __try
    {
        int index = 0;

        memset(pThis, 0, sizeof(*pThis));
        while (argc)
        {
            int argumentsUsed = parseArgument(pThis, index, argc, argv);
            argc -= argumentsUsed;
            argv += argumentsUsed;
            index += argumentsUsed;
        }
        throwIfRequiredArgumentNotSpecified(pThis);
        pThis->pMemory = MemorySim_Init();
        loadImageFile(pThis);
        GdbLogParse(pThis->pMemory, &pThis->context, pThis->pDumpFilename);
    }
    __catch
    {
        displayCopyrightNotice();
        displayUsage();
        MemorySim_Uninit(pThis->pMemory);
        pThis->pMemory = NULL;
        __rethrow;
    }
}

static int parseArgument(CrashDebugCommandLine* pThis, int index, int argc, const char** ppArgs)
{
    if (hasDoubleDashPrefix(*ppArgs))
        return parseFlagArgument(pThis, argc, ppArgs);
    else
        __throw(invalidArgumentException);
}

static int hasDoubleDashPrefix(const char* pArgument)
{
    return pArgument[0] == '-' && pArgument[1] == '-';
}

static int parseFlagArgument(CrashDebugCommandLine* pThis, int argc, const char** ppArgs)
{
    if (0 == strcasecmp(*ppArgs, "--image"))
        return parseImageFilenameOption(pThis, argc - 1, &ppArgs[1]);
    else if (0 == strcasecmp(*ppArgs, "--dump"))
        return parseDumpFilenameOption(pThis, argc - 1, &ppArgs[1]);
    else
        __throw(invalidArgumentException);
}

static int parseImageFilenameOption(CrashDebugCommandLine* pThis, int argc, const char** ppArgs)
{
    return parseFilenameOption(pThis, argc, ppArgs, &pThis->pImageFilename);
}

static int parseDumpFilenameOption(CrashDebugCommandLine* pThis, int argc, const char** ppArgs)
{
    return parseFilenameOption(pThis, argc, ppArgs, &pThis->pDumpFilename);
}
static int parseFilenameOption(CrashDebugCommandLine* pThis, int argc, const char** ppArgs, const char** ppFilename)
{
    if (argc < 1)
        __throw(invalidArgumentException);

    *ppFilename = ppArgs[0];
    return 2;
}

static void throwIfRequiredArgumentNotSpecified(CrashDebugCommandLine* pThis)
{
    if (!pThis->pImageFilename || !pThis->pDumpFilename)
        __throw(invalidArgumentException);
}

static void loadImageFile(CrashDebugCommandLine* pThis)
{
    FILE* volatile pFile = NULL;
    char* volatile pBuffer = NULL;

    __try
    {
        long   fileSize = 0;
        size_t bytesRead = 0;

        pFile = fopen(pThis->pImageFilename, "r");
        if (!pFile)
            __throw(fileException);
        fileSize = GetFileSize(pFile);

        pBuffer = malloc(fileSize);
        if (!pBuffer)
            __throw(outOfMemoryException);

        bytesRead = fread(pBuffer, 1, fileSize, pFile);
        if ((long)bytesRead != fileSize)
            __throw(fileException);

        MemorySim_CreateRegion(pThis->pMemory, FLASH_BASE_ADDRESS, fileSize);
        MemorySim_LoadFromFlashImage(pThis->pMemory, pBuffer, fileSize);

        free(pBuffer);
        fclose(pFile);
    }
    __catch
    {
        free(pBuffer);
        if (pFile)
            fclose(pFile);
        __rethrow;
    }
}


void CrashDebugCommandLine_Uninit(CrashDebugCommandLine* pThis)
{
    MemorySim_Uninit(pThis->pMemory);
}
